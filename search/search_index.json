{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"Reloaded-II File Emulation Framework \ud83c\udf88 Let's screw with binaries \ud83c\udf88 <p>A framework for creating virtual files at runtime.</p>"},{"location":"index.html#about-the-framework","title":"About The Framework","text":"<p>The file emulation framework is a framework for intercepting Windows API calls related to the reading of files from disk; in order to trick games into loading files that don't really exist.  </p> <p>It builds on top of previous experiments with Reloaded, namely AFS Redirector, ONE Redirector and Persona 4 Golden PC modloader.  </p>"},{"location":"index.html#a-user-friendly-example","title":"A User Friendly Example","text":"<p>Replacing files inside big archives without creating new ones.  </p> <p></p> <p></p> <p>In this case, the following files would replace the 7th, 8th, 9th and 10th file in the <code>SH_VOICE_E.afs</code> archive.  </p>"},{"location":"index.html#how-it-works","title":"How It Works","text":"<p>By intercepting API calls used to open files, get their properties and read from them, we can essentially create files 'on the fly'; allowing us to perform various forms of post processing such as merging archives in a way that requires zero knowledge of the application running under the hood.</p> <p>In practice this is extremely effective, the original AFS Redirector is known for being able to work with 10+ games, including those behind emulators.</p> <p>Projects using this framework are referred to as 'emulators' hence the name <code>File Emulation Framework</code>; that name is derived from the original projects which simulated nonexistent archive files.</p>"},{"location":"index.html#performance-impact","title":"Performance Impact","text":"<p>This one varies with a lot of factors, such as number of emulators used, the emulators themselves, amount of data emulated, etc.</p> <p>In most realistic use cases, the emulators usually have negligible performance impact that is completely invisible to the end user. </p> <p>Usually first access to a file may be delayed for a small amount of time (<code>1-3ms on existing emulators at time of writing</code>) but this should usually be invisible to the end user. Penalty in speed of access to data of emulated files is negligible in practice. </p> <p>The biggest penalty tends to be from reading multiple files instead of just one; as the benefits of purely sequential reads may no longer apply.</p>"},{"location":"index.html#how-to-contribute-wiki","title":"How to Contribute (Wiki)","text":"<ul> <li>Contributing to the Wiki: Online</li> <li>Contributing to the Wiki: Locally</li> </ul>"},{"location":"index.html#credits-attributions","title":"Credits, Attributions","text":"<ul> <li>Header icon created by Freepik - Flaticon</li> </ul>"},{"location":"emulator-types.html","title":"Emulator Types","text":"<p>Info</p> <p>Describes the rules, and the two possible <code>'types'</code>/ways of implementing emulators.  </p>"},{"location":"emulator-types.html#type-a-stream-based","title":"Type A (Stream Based)","text":"<p>Info</p> <p>One way to produce emulators is through the use of 'streaming'. That is, keeping the minimal amount of information on how to construct the file in memory, while building the rest of the file on the fly as the application requests it.  </p> <p>In the case of archives, usually applications will read the header of the file, store it, and use that metadata to make further reads from the file.  You should replicate this sort of workflow.</p> <p>In this case of archives, you would usually produce the whole header of your new virtual archive and store it in memory.  Then as the application creates requests to read the data of the files inside, automatically load said data using either the original archive file, or using new files from the filesystem. </p> <p>Tip</p> <p>Always implement emulators using this technique, if possible. It may be a bit harder, but is far more optimal approach performance wise.</p>"},{"location":"emulator-types.html#type-b-non-stream-based","title":"Type B (Non-stream Based)","text":"<p>Info</p> <p>In some cases, the stream approach might not make sense; for example in cases where parts of old files might not be directly reusable, or simply hard to reuse.  </p> <p>One example of this kind of situation is with combining text/code/scripts. </p> <p>In this case, you should simply merge the files manually, to produce a new standalone file, just like you would with a regular program.  </p> <p>If dealing with small files, it is recommended to write the final file to a <code>MemoryManagerStream</code>, and use that stream to fulfill read requests; as reading small files from disk is slow. For very small files (&lt;64KiB) use a <code>MemoryStream</code> instead. </p> <p>For big files (&gt;100MB) or where the total expected sum of the files is big (2GB+), consider writing them to disk, and fulfilling the read requests from disk.</p>"},{"location":"implementation-rules.html","title":"Implementation Rules","text":""},{"location":"implementation-rules.html#implementation-rules","title":"Implementation Rules","text":"<p>Danger</p> <p>Please do not implement hacks for things such as <code>hotswapping</code> files at runtime by serving different data on future loads; or writing to buffers passed by the application. Not only are these hard to debug but emulators should be as application agnostic as possible.  </p> <p>APIs to enable those features can be provided for other mods to use (e.g. via Dependency Injection), but must not be enabled by default.  </p> <p>This framework prioritises performance and compatibility first.  </p>"},{"location":"implementation-rules.html#always-stream-if-possible","title":"Always Stream if Possible","text":"<p>Implement your emulator as a <code>Type A</code> whenever possible.  </p> <p>While <code>Type B</code> may be easier, since you can potentially simply use existing libraries with <code>MemoryManagerStream</code>, it will have a noticeable impact on first load time; and the increased memory usage may lead to increased swapping to/from pagefile. The pagefile also has limits.</p>"},{"location":"implementation-rules.html#memory-usage","title":"Memory Usage","text":"<p>Warning</p> <p>Use memory mapped files for small files only. It is suggested to write bigger files (&gt;100MB) out to disk directly.</p> <p>If using using <code>Type B</code> emulation, use memory mapped files (<code>MemoryManager</code> &amp; <code>MemoryManagerStream</code>) when possible. Failure to do so risks virtual address space starvation in 32-bit processes.  </p> <p>When using memory mapped files, only sections that are currently mapped/viewed use up the address space, in the case of <code>MemoryManager</code>, this means only <code>AllocationGranularity</code> is used.  </p> <p>Warning</p> <p>For files smaller than <code>AllocationGranularity</code> use a <code>MemoryStream</code> instead to avoid wasting address space.</p>"},{"location":"implementation-rules.html#use-lazy-loading-immutability","title":"Use Lazy Loading &amp; Immutability","text":"<p>Implementations should only produce/initialize emulated files when they are first requested by the application; i.e. when a handle is opened.  </p> <p>Once produced, the file emulator should always serve the same file on subsequent requests/handle openings. i.e. generated files persist for application lifetime.</p>"},{"location":"implementation-rules.html#always-read-all-requested-bytes","title":"Always Read All Requested Bytes","text":"<p>Info</p> <p>A common programmer error is to issue a <code>Read()</code> command on a file stream and assume that all bytes requested will be given back.</p> <p>This is not often the case and even I have been guilty of this mistake for a very long time. If possible, DO NOT return less than the number of bytes requested (when possible) in order to shield against buggy software implementations.  </p> <p>While this may sound more complicated than it should for e.g. archives, it really should not be. If you have some code for an archive emulator's <code>ReadData</code> that looks something like:</p> <pre><code>// If getting header in Type-A emulator\nif (isHeaderRead)\n{\n    // We are reading the file header, let's give the program the false header.\n    var fakeHeaderSpan = new Span&lt;byte&gt;(afsFile.HeaderPtr, afsFile.Header.Length);\n    var endOfHeader = offset + length;\n    if (endOfHeader &gt; fakeHeaderSpan.Length)\n        length -= (uint)(endOfHeader - fakeHeaderSpan.Length);\n\n    var slice = fakeHeaderSpan.Slice((int)offset, (int)length);\n    slice.CopyTo(bufferSpan);\n\n    numReadBytes = slice.Length;\n    return true;\n}\n\n// Else we are reading a file, let's pass a new file to the buffer.\nif (afsFile.TryFindFile((int)offset, (int)length, out var virtualFile))\n{\n    numReadBytes = virtualFile.GetData(bufferSpan);\n    return true;\n}\n</code></pre> <p>Then you can just invoke this function multiple times until the requested amount of bytes have been filled.</p> <p>Tip</p> <p>A recommended way of building stream (Type A) based emulators emulators is MultiStream. With MultiStream you can avoid this issue entirely, and usually implement <code>ReadData</code> in ~5 lines. </p>"},{"location":"implementation-rules.html#hooks-always-enabled","title":"Hooks Always Enabled","text":"<p>Don't deactivate your hooks at any point. All hooks should always be enabled to allow for recursive use of the emulators.</p>"},{"location":"implementation-rules.html#data-access-patterns","title":"Data Access Patterns","text":"<p>Tip</p> <p>Assume data can be accessed in any order, and reads may begin from any offset and/or length.  </p>"},{"location":"implementation-utilities.html","title":"Utilities","text":""},{"location":"implementation-utilities.html#high-performance-logging","title":"High Performance Logging","text":"<p>Tip</p> <p>The <code>Logger</code> class in <code>FileEmulationFramework.Lib</code> provides an abstraction over Reloaded's <code>ILogger</code> that allows you to conditionally make log messages without the need for memory allocation.  </p> <pre><code>_log = new Logger(_logger, _configuration.LogLevel);\n</code></pre> <p>Methods such as <code>_log.Info</code> will only create the string and log it if that specific log level is enabled; provided you use the various overloads that accept generics e.g. <code>Info&lt;T1&gt;(string format, T1 item1)</code>.</p> <p>Avoid the overloads with single message parameter unless you require custom formatting; in which case you should add manual guards via <code>if (_log.IsEnabled(level))</code>.</p>"},{"location":"implementation-utilities.html#file-slices","title":"File Slices","text":"<p>Info</p> <p>The <code>FileSlice</code> class can be used to provide an abstraction that allows you to read a region of a given file.  </p> <p>When building Stream based emulators, you will often provide a mixture of the original data and new data. This class will allow you to more easily fetch the original data when needed.</p>"},{"location":"implementation-utilities.html#merging-file-slices","title":"Merging File Slices","text":"<p>Info</p> <p>Slices of the same file that touch each other (e.g. <code>0-4095</code> + <code>4096-65536</code>) can be merged into singular, larger slices.  </p> <p>This is sometimes possible when working with archives containing file data whereby multiple files are laid out side by side.</p> <p>Tip</p> <p>Merging can help improve performance of resolving <code>Read</code> requests (i.e. <code>IEmulator.ReadData</code>). Specifically the performance of StreamMixer</p> <p>Try using the <code>FileSlice.TryMerge</code> API.  </p> <p>If you are using streams backed by <code>FileSlice</code> (that use <code>IFileSliceStream</code>), you can merge them using <code>FileSliceStreamExtensions.TryMerge</code> for individual streams or <code>FileSliceStreamExtensions.MergeStreams</code> for collections.  </p>"},{"location":"implementation-utilities.html#file-slice-stream","title":"File Slice Stream","text":"<p>Info</p> <p>The <code>FileSliceStream</code> classes provide an abstraction that wrap <code>FileSlice</code>(s). Currently two implementations exist, <code>FileSliceStreamFs</code> and <code>FileSliceStreamW32</code>.  </p> <p>Tip</p> <p><code>FileSliceStreamFs</code> is backed by FileStream. Use this class if application makes many reads with small amount of data (e.g. &lt;= 256 byte reads.)</p> <p>Tip</p> <p><code>FileSliceStreamW32</code> is backed by Windows API. Use this class if reads above 4096 bytes are expected.</p> <p>Should be simple enough.</p>"},{"location":"implementation-utilities.html#offsetrange","title":"OffsetRange","text":"<p>A utility class that stores a start and end offset [inclusive]. Can be used for testing for overlaps, testing of address is in range, etc.</p>"},{"location":"implementation-utilities.html#multi-stream","title":"Multi Stream","text":"<p>Info</p> <p><code>MultiStream</code> combines multiple streams into a single stream with read and seek support. Highly optimised.</p> <p>Tip</p> <p>It is possible to build entire files using this stream and just resolve read requests <code>IEmulator.ReadData</code> by seeking and reading from this stream. This is a recommended approach.</p>"},{"location":"implementation-utilities.html#padding-stream","title":"Padding Stream","text":"<p>Info</p> <p>Stream that fills the read buffer with a single, user specified byte.  </p> <p>This can be used in conjunction with MultiStream to provide padding for emulated files.</p>"},{"location":"implementation-utilities.html#mathematics","title":"Mathematics","text":"<p>Info</p> <p>This class has some common mathematics related operations, such as rounding up numbers to add padding to files.</p>"},{"location":"implementation-utilities.html#fast-directory-searcher","title":"Fast Directory Searcher","text":"<p>Tip</p> <p>The <code>WindowsDirectorySearcher</code> class can be used for extremely fast searching of files on the filesystem. </p> <p>This implementation is around 3.5x faster than the built in .NET one at the time of writing; using the innermost <code>NtQueryDirectoryFile</code> API for fetching files.</p> <p>It's forked from the implementation in <code>Reloaded.Mod.Loader.IO</code>; with Multithreading removed since it wouldn't be helpful with our too small data/file sets.</p>"},{"location":"routing.html","title":"Routing","text":"<p>Info</p> <p>This page describes the basics of how files on disk are used to modify existing files through the use of 'emulators'.</p> <p>When virtual/emulated files are being built, the library keeps track of a <code>Route</code>.  </p> <p>This 'route' is a combination of the base file, and the name of each recursive internal file(s): - Base file uses full path, e.g. <code>&lt;GameFolder&gt;/English/Sound.afs</code>. - Internal files are delimited by <code>/</code> character.  </p> <p>e.g. File <code>00000.adx</code> in <code>&lt;GameFolder&gt;/English/Sound.afs</code> would make the full path <code>&lt;GameFolder&gt;/English/Sound.afs/00000.adx</code>.  </p> <p>This route is passed onto the individual <code>emulators</code> to work with.  </p>"},{"location":"routing.html#file-resolution","title":"File Resolution","text":"<p>Info</p> <p>Describes how files in user mods are matched to the file to be modified.  </p> <p>Each emulator will have its own folder under the <code>FEmulator</code> folder inside user made mods, so the emulator for CRIWARE <code>.AFS</code> would use <code>FEmulator/AFS</code>.  </p> <p>Folder names are used for resolving what files should be modified by each 'emulator'; with the folder name corresponding to the file to modify and the contents of the folder being the input to the 'emulator'.  </p> <p>In the case of 'archive emulators' like the AFS ones, placing files inside can be used to override existing files inside the source <code>.afs</code> file.</p> <ul> <li>Folder <code>Sound.afs/00000.adx</code> in <code>FEmulator/AFS</code> will override files named <code>00000.adx</code> in all <code>Sound.afs</code> loaded.  </li> </ul> <p>Additional folders can be used to specify the file to be overwritten more precisely. This can be useful when multiple files of the same name exist.  </p> <p>For example, <code>English/Sound.afs/00000.adx</code> in <code>FEmulator/AFS</code>: - Will match <code>&lt;GameFolder&gt;/English/Sound.afs</code> - Will not match <code>&lt;GameFolder&gt;/Japanese/Sound.afs</code> </p> <p>Comparisons performed are case insensitive. Partial matches e.g. <code>nglish/Sound.afs</code> are allowed, but are discouraged from use.</p>"},{"location":"routing.html#recursive-resolution","title":"Recursive Resolution","text":"<p>Info</p> <p>Emulators work recursively.  Meaning you can emulate a file inside an emulated file.</p> <p>In the case of archives, suppose you have <code>textures.one</code> and inside that <code>textures.txd</code>.  </p> <p>You can inject into <code>textures.txd</code> by doing the following: - Add <code>FEmulator/ONE/textures.one/textures.txd</code>.  [inject unmodified <code>textures.txd</code> into <code>textures.one</code>]. - Add <code>FEmulator/TXD/textures.txd/texture_001.dds</code>. [inject texture_001 into <code>textures.txd</code>]  </p>"},{"location":"routing.html#file-usage","title":"File Usage","text":"<p>The File Resolution section used the 'AFS Redirector' as an example of inserting/replacing files into an archive by using existing files.  </p> <p>The contents of the folder corresponding to the emulated file are open to the emulator's interpretation.  </p> <p>For example, for an ADX (sound file) emulator, <code>Musictrack.adx/settings.json</code> could be a valid file; and the emulator use <code>settings.json</code> to perform post processing the file such as sound normalization or concatenating music tracks.  </p> <p>Equally well, for archives which use compression for internal files, having pre-compressed files is also valid.</p>"},{"location":"emulators/afs.html","title":"AFS [CRI Middleware]","text":"<p>Info</p> <p>AFS is a general purpose data container from CRI Middleware. Code for this emulator lives inside main project's GitHub repository.  </p>"},{"location":"emulators/afs.html#supported-applications","title":"Supported Applications","text":"<p>This emulator should support every application out there.  </p> <p>It has been tested with the following: - Sonic Heroes (PC) - Silent Hill 3 (PC) - Sonic Adventure 2 (PC) - Shadow The Hedgehog (Japanese, GameCube, Dolphin Emulator, Running from FileSystem)  </p>"},{"location":"emulators/afs.html#example-usage","title":"Example Usage","text":"<p>A. Add a dependency on this mod in your mod configuration. (via <code>Edit Mod</code> menu dependencies section, or in <code>ModConfig.json</code> directly)</p> <pre><code>\"ModDependencies\": [\"reloaded.universal.fileemulationframework.afs\"]\n</code></pre> <p>B. Add a folder called <code>FEmulator/AFS</code> in your mod folder. C. Make folders corresponding to AFS Archive names, e.g. <code>SH_VOICE_E.AFS</code>.  </p> <p>Files inside AFS Archives are accessed by index, i.e. order in the archive: 0, 1, 2, 3 etc.  </p> <p>Inside each folder make files, with names corresponding to the file's index.  </p>"},{"location":"emulators/afs.html#examples","title":"Example(s)","text":"<p>To replace a file in an archive named <code>EVENT_ADX_E.AFS</code>...</p> <p>Adding <code>FEmulator/AFS/EVENT_ADX_E.AFS/0.adx</code> to your mod would replace the 0th item in the original AFS Archive.</p> <p>Adding <code>FEmulator/AFS/EVENT_ADX_E.AFS/32.aix</code> to your mod would replace the 32th item in the original AFS Archive.</p> <p></p> <p>File names can contain other text, but must start with a number corresponding to the index.  </p> <p>Info</p> <p>For audio playback, you can usually place ADX/AHX/AIX files interchangeably. e.g. You can place a <code>32.adx</code> file even if the original AFS archive has an AIX/AHX file inside in that slot. </p> <p>Info</p> <p>A common misconception is that AFS archives can only be used to store audio. This is in fact wrong. AFS archives can store any kind of data, it's just that using AFS for audio was very popular.</p> <p>Info</p> <p>If dealing with AFS audio; you might need to make sure your new files have the same channel count as the originals.   </p>"},{"location":"emulators/arc.html","title":"ARC [JSRF]","text":"<p>Info</p> <p>ARC (or ARCL) is a archive format used in Jet Set Radio. Code for this emulator lives inside main project's GitHub repository.  </p>"},{"location":"emulators/arc.html#supported-applications","title":"Supported Applications","text":"<p>This emulator should support every application that uses ARCs (though they have only been found in Jet Set Radio).  </p> <p>It has been tested with the following: - Jet Set Radio HD (PC)</p>"},{"location":"emulators/arc.html#example-usage","title":"Example Usage","text":"<p>A. Add a dependency on this mod in your mod configuration. (via <code>Edit Mod</code> menu dependencies section, or in <code>ModConfig.json</code> directly)</p> <pre><code>\"ModDependencies\": [\"reloaded.universal.fileemulationframework.arc\"]\n</code></pre> <p>B. Add a folder called <code>FEmulator/ARC</code> in your mod folder. C. Make folders corresponding to ARC Archive names, e.g. <code>IMAGES.ARC</code>.  </p> <p>Files inside ARC Archives are accessed by the path and filename.  </p> <p>Inside each folder make files, with names corresponding to the original file's contents.  </p>"},{"location":"emulators/arc.html#examples","title":"Example(s)","text":"<p>To replace a file in an archive named <code>IMAGES.ARC</code>...</p> <p>Adding <code>FEmulator/ARC/CUSTOM/IMAGES.ARC/arrow.png</code> to your mod would replace the item at <code>arrow.png</code> in the original ARC Archive.</p> <p>Adding <code>FEmulator/ARC/CUSTOM/IMAGES.ARC/PS3/button_a.png</code> to your mod would replace the item at <code>/PS3/button_a.png</code> in the original ARC Archive.</p> <p>The contents of each ARC file can be found using the JSR ARC Tool, found here.</p> <p>Info</p> <p>The files that are being replaced must be the same file format as the new files, you cant replace a .PNG with a .JPG!</p>"},{"location":"emulators/awb.html","title":"AWB [CRI Middleware]","text":"<p>Info</p> <p>AWB is a general purpose data container from CRI Middleware. It's the successor to AFS and uses the header AFS2. Code for this emulator lives inside main project's GitHub repository.  </p>"},{"location":"emulators/awb.html#supported-applications","title":"Supported Applications","text":"<p>This emulator should support every application out there.  </p> <p>It has been tested with the following: - Bayonetta (PC) - Persona 5 Royal (PC) [Note: ADX files Require Encryption]  </p>"},{"location":"emulators/awb.html#example-usage","title":"Example Usage","text":"<p>A. Add a dependency on this mod in your mod configuration. (via <code>Edit Mod</code> menu dependencies section, or in <code>ModConfig.json</code> directly)</p> <pre><code>\"ModDependencies\": [\"reloaded.universal.fileemulationframework.awb\"]\n</code></pre> <p>B. Add a folder called <code>FEmulator/AWB</code> in your mod folder. C. Make folders corresponding to AWB Archive names, e.g. <code>BGM000.AWB</code>.  </p> <p>Files inside AWB Archives are accessed by index, i.e. order in the archive: 0, 1, 2, 3 etc.  </p> <p>Inside each folder make files, with names corresponding to the file's index.  </p>"},{"location":"emulators/awb.html#examples","title":"Example(s)","text":"<p>To replace a file in an archive named <code>BGM000.AWB</code>...</p> <p>Adding <code>FEmulator/AWB/BGM000.AWB/0.adx</code> to your mod would replace the 0th item in the original AWB Archive.</p> <p>Adding <code>FEmulator/AWB/BGM000.AWB/32.aix</code> to your mod would replace the 32th item in the original AWB Archive.</p> <p></p> <p>File names can contain other text, but must start with a number corresponding to the index.  </p>"},{"location":"emulators/awb.html#acb-bdx-patching","title":"ACB &amp; BDX Patching","text":"<p>Info</p> <p>When an AWB is accompanied by an ACB file, the header of the AWB file is usually ignored and instead read from ACB which makes life difficult.  </p> <p>When the emulator sees an ACB file, it will automatically try to match any found AWB header with previously patched AWB and patch it inside the ACB if there's a match. </p> <p>Warning</p> <p>In some cases, the ACB may be loaded BEFORE the AWB, in which case the emulator will try load the AWB by replacing the extension of the file from <code>.acb</code> to <code>.awb</code>.  </p> <p>If you run into a title where the ACB and AWB names don't match and require custom file linking, let me know.</p>"},{"location":"emulators/awb.html#notes-afs","title":"Notes (AFS)","text":"<p>The following notes/limitations are known to exist in AFS, and may still apply in AWB, they have been untested.</p> <p>Info</p> <p>For audio playback, you can usually place ADX/AHX/AIX files interchangeably. e.g. You can place a <code>32.adx</code> file even if the original AWB archive has an AIX/AHX file inside in that slot. </p> <p>Info</p> <p>If dealing with AWB audio; you might need to make sure your new files have the same channel count as the originals.   </p>"},{"location":"emulators/bf.html","title":"BF [Atlus]","text":"<p>Info</p> <p>BF is a script file used by Atlus, for more information on the format check out ShrineFox's intro to scripting. </p> <p>Code for this emulator lives inside main project's GitHub repository.  </p>"},{"location":"emulators/bf.html#supported-applications","title":"Supported Applications","text":"<p>A number of Atlus games such as Persona, SMT, and Catherine use BF files. Any that Atlus Script Compiler has libraries for should work, however, this has only been tested with: </p> <ul> <li>Persona 3 Portable (PC)  </li> <li>Persona 4 Golden (PC)  </li> <li>Persona 5 Royal (PC)  </li> </ul> <p>For games other than these, script compiler arguments need to be supplied as detailed in Custom Script Compiler Args. </p>"},{"location":"emulators/bf.html#example-usage","title":"Example Usage","text":"<p>As this mod is primarily intended for use with the PC Persona games, it is reccomended that you use Persona Essentials which has this as a dependency. However, the steps for using it on its own are very similar to with Persona Essentials:</p> <p>A. Add a dependency on this mod in your mod configuration. (via <code>Edit Mod</code> menu dependencies section, or in <code>ModConfig.json</code> directly)</p> <pre><code>\"ModDependencies\": [\"reloaded.universal.fileemulationframework.bf\"]\n</code></pre> <p>B. Add a folder called <code>FEmulator/BF</code> in your mod folder. C. Make a <code>.flow</code> file with the same name as the bf you want to edit, e.g. <code>f007.flow</code> to edit <code>f007.bf</code> (this can be in subfolders as per  Routing). D. In the <code>.flow</code> file include any new procedures and hooks of existing procedures from the base <code>.bf</code> file  </p> <p>Warning</p> <p>Only include new procedures and hooked procedures, do not copy and paste the entire decompiled bf into your flow.</p> <p>To hook a procedure add <code>_hook</code> to the end of the name of the original (e.g. to hook <code>init</code> make a procedure called <code>init_hook</code>)</p>"},{"location":"emulators/bf.html#message-hooking","title":"Message Hooking","text":"<p>If you just want to change existing messages inside of a <code>bf</code> you can do so using message hooking which works very similarly to regular flowscript merging. </p> <p>To do so:</p> <p>A. Follow steps A and B from above.   B. Make a <code>.msg</code> file with the same name as the bf you want to edit, e.g. <code>f007.msg</code> to edit messages in <code>f007.bf</code>  C. In the <code>.msg</code> file include any messages that you want to edit from the base <code>.bf</code> file.</p> <p>Warning</p> <p>Only include edited messages, do not copy and paste the entire decompiled msg file into your new msg.</p> <p>The edited messages must have exactly the same names as the originals otherwise they will not be overwritten and instead will be added.</p> <p>Note that you can also hook messages in flow files by having messages with the same name as original ones in any imported <code>.msg</code> files. Normally script compiler would ignore duplicate named messages, however, the version in BF Emulator has been modified to instead overwrite them.</p>"},{"location":"emulators/bf.html#forced-procedure-indices","title":"Forced Procedure Indices","text":"<p>In some cases you will need to add new procedures to a <code>bf</code> which are at a specific index, such as when adding new interactable NPCs. In this case you can force a specific index by adding <code>_index_x</code> to the end of the procedure's name.</p> <p>For example, if you have a new NPC that calls procedure <code>21</code>, in your <code>.flow</code> file should have a procedure with a name like <code>npc_thing_index_21</code> to ensure your new procedure is always at index <code>21</code> (the stuff before <code>_index_21</code> is completely arbitrary).</p> <p>Info</p> <p>This is neceessary as other mods hooking functions in the same <code>bf</code> could potentially change the index of your procedures if they are not forced.</p>"},{"location":"emulators/bf.html#script-compiler-library-overrides","title":"Script Compiler Library Overrides","text":"<p>In some cases you will want to utilise custom flowscript functions provided either by your mod or a dependency. In these cases you can use library overrides to replace the information about existing (generally unused) functions with your custom ones. </p> <p>To do so:</p> <p>A. Create a file named <code>Functions.json</code> in your <code>FEmulator/BF</code> folder. B. Inside of <code>Functions.json</code> copy the information of the changed functions into the file inside of a json array.</p> <p>For example, to use the P3P Movie Player mod's <code>CUSTOM_MOVIE_PLAY</code> function you would have the following in <code>Functions.json</code></p> <pre><code>[\n  {\n    \"Index\": \"0x0004\",\n    \"ReturnType\": \"void\",\n    \"Name\": \"CUSTOM_MOVIE_PLAY\",\n    \"Description\": \"Custom function that plays a usm based on its id. This REQUIRES the Movie Player mod to work!\",\n    \"Parameters\": [\n      {\n        \"Type\": \"int\",\n        \"Name\": \"CutsceneId\",\n        \"Description\": \"The id of the usm to play, the usm should be in \\\\data\\\\sound\\\\usm and be called CutsceneId.usm (e.g. 21.usm for id 21)\"\n      }\n    ]\n  }\n]\n</code></pre> <p>Where that information was copied directly from the mod's readme.</p> <p>Warning</p> <p>Do not change the information of functions that are not unused (such as changing the name of undocumented functions). If any other mod hooks the same bf and uses those functions they will be unable to compile.</p> <p>If you have documented previously unknown functions you should make a pull request with these changes to the main Atlus-Script-Tools repository, this can then be merged into BF Emulator at a later time. </p> <p>This can also be done with custom enums by adding an <code>Enums.json</code> file into <code>FEmulator/BF</code> and adding the information in a similar manner. For example:</p> <pre><code>[\n    {\n        \"Name\": \"Cutscene\",\n        \"Description\": \"This enum represents different movies added by cutscenes restored\",\n        \"Members\": [\n            {\n                \"Name\": \"First\",\n                \"Value\": 1,\n                \"Description\": \"\"\n            }\n        ]\n    }\n]\n</code></pre> <p>This enum can then be used in your code like: <code>CUSTOM_MOVIE_PLAY( Cutscene.First );</code></p>"},{"location":"emulators/bf.html#custom-script-compiler-args","title":"Custom Script Compiler Args","text":"<p>Info</p> <p>If you are doing this to use BF Emulator with an unsupported game you could instead make a pull request, adding automatic support for it by adding to the constructor in BfEmulator.cs.</p> <p>If you want to use BF Emulator on a game that is not automatically supported you will need to supply Atlus Script Compiler with the correct arguments to compile the bf for it.</p> <p>To do so:</p> <p>A. Create a file named <code>CompilerArgs.json</code> in your <code>FEmulator/BF</code> folder.  B. Inside of <code>CompilerArgs.json</code> use the following template with the appropriate arguments (which can usually be found in the Script Compiler GUI repo)</p> <pre><code>{\n    \"Library\": \"P3P\",\n    \"Encoding\": \"P3\",\n    \"OutFormat\": \"V1\"\n}\n</code></pre>"},{"location":"emulators/bmd.html","title":"BMD [Atlus]","text":"<p>Info</p> <p>BMD is a script file used by Atlus, for more information on the format check out ShrineFox's intro to scripting. </p> <p>Code for this emulator lives inside main project's GitHub repository.  </p>"},{"location":"emulators/bmd.html#supported-applications","title":"Supported Applications","text":"<p>A number of Atlus games such as Persona, SMT, and Catherine use BMD files. Any that Atlus Script Compiler has libraries for should work, however, this has only been tested with: </p> <ul> <li>Persona 3 Portable (PC)  </li> <li>Persona 4 Golden (PC)  </li> <li>Persona 5 Royal (PC)  </li> </ul> <p>For games other than these, script compiler arguments need to be supplied as detailed in Custom Script Compiler Args. </p>"},{"location":"emulators/bmd.html#example-usage","title":"Example Usage","text":"<p>As this mod is primarily intended for use with the PC Persona games, it is recommended that you use Persona Essentials which has this as a dependency. However, the steps for using it on its own are very similar to with Persona Essentials:</p> <p>A. Add a dependency on this mod in your mod configuration. (via <code>Edit Mod</code> menu dependencies section, or in <code>ModConfig.json</code> directly)</p> <pre><code>\"ModDependencies\": [\"reloaded.universal.fileemulationframework.bmd\"]\n</code></pre> <p>B. Add a folder called <code>FEmulator/BMD</code> in your mod folder. C. Make a <code>.msg</code> file with the same name as the bmd you want to edit, e.g. <code>e722_103.msg</code> to edit messages in <code>e722_103.bmd</code>  D. In the <code>.msg</code> file include any messages that you want to edit from the base <code>.bmd</code> file.</p> <p>Warning</p> <p>Only include edited messages, do not copy and paste the entire decompiled msg file into your new msg.</p> <p>The edited messages must have exactly the same names as the originals otherwise they will not be overwritten and instead will be added.</p> <p>Normally script compiler would ignore duplicate named messages, however, the version in BMD Emulator has been modified to instead overwrite them.</p>"},{"location":"emulators/bmd.html#custom-script-compiler-args","title":"Custom Script Compiler Args","text":"<p>Todo</p> <p>The link in the below is copypasted from bf.md and is not correct.</p> <p>Info</p> <p>If you are doing this to use BMD Emulator with an unsupported game you could instead make a pull request, adding automatic support for it by adding to the constructor in BfEmulator.cs.</p> <p>If you want to use BMD Emulator on a game that is not automatically supported you will need to supply Atlus Script Compiler with the correct arguments to compile the bmd for it.</p> <p>To do so:</p> <p>A. Create a file named <code>CompilerArgs.json</code> in your <code>FEmulator/BMD</code> folder.  B. Inside of <code>CompilerArgs.json</code> use the following template with the appropriate arguments (which can usually be found in the Script Compiler GUI repo)</p> <pre><code>{\n    \"Library\": \"P3P\",\n    \"Encoding\": \"P3\",\n    \"OutFormat\": \"V1\"\n}\n</code></pre>"},{"location":"emulators/one-heroes.html","title":"ONE [Sonic Heroes]","text":"<p>Info</p> <p>.ONE is a general purpose data container developed (presumably) at some branch of Sonic Team.  This emulator is for the Sonic Heroes variant. Code for thie emulator lives inside the main project's GitHub repository.  </p>"},{"location":"emulators/one-heroes.html#supported-applications","title":"Supported Applications","text":"<ul> <li>Sonic Heroes (PC)  </li> <li>Sonic Heroes XBOX (Emu)  </li> </ul> <p>and any tools that operate on the format...  </p>"},{"location":"emulators/one-heroes.html#example-usage","title":"Example Usage","text":"<p>A. Add a dependency on this mod in your mod configuration. (via <code>Edit Mod</code> menu dependencies section, or in <code>ModConfig.json</code> directly)</p> <pre><code>\"ModDependencies\": [\"reloaded.universal.fileemulationframework.heroes.one\"]\n</code></pre> <p>B. Add a folder called <code>FEmulator/ONE</code> in your mod folder. C. Make folders corresponding to ONE Archive names, e.g. <code>game_disp.one</code>.  </p> <p>Put files inside that folder to perform various actions.  </p> <p>Info</p> <p>Refer to Routing if you want to use more specific file names.</p>"},{"location":"emulators/one-heroes.html#addingreplacing-files","title":"Adding/Replacing Files","text":"<p>Warning</p> <p>Uncompressed files will suffer from a small load time penalty upon first load of the file, since they will need to be compressed as the ONE format does not support uncompressed files.  </p> <p>Simply place the file in your <code>.one</code> directory.  </p> <p></p> <p>(game_disp.one/GAME_DISP.TXD)</p> <p>Files placed in the directory will replace the files stored inside the ONE archive.  </p> <p>Tip</p> <p>You should pre-compress your files using this tool to avoid load time penalties. Recommend buffer size of 8191.  </p> <p>Add <code>.PRS</code> extension to compressed files. e.g. <code>GAME_DISP.TXD.PRS</code>.  </p> <p>Danger</p> <p>Seriously, please compress your files.  Uncompressed files are backed by pagefile, overuse of those may lead to performance problems.</p> <p>Note</p> <p>Pre-compressing files prevents them from working with other emulators. If there would hypothetically be, a TXD emulator some day; and you want to merge some textures in; don't pre-compress your TXD.  </p>"},{"location":"emulators/one-heroes.html#deleting-files","title":"Deleting Files","text":"<p>In order to delete a file, create an empty file with the name of the file and extension <code>.del</code>.</p> <p></p> <p>e.g. This would remove the file <code>GAME_DISP.TXD</code> from the original archive.  </p> <p>Note</p> <p>The archive builder works in the order <code>Delete</code> then <code>Add</code>. If a file is first deleted, it can be re-added by either the same or another mod.  </p>"},{"location":"emulators/pak.html","title":"PAK [Atlus]","text":"<p>Info</p> <p>PAK is a general purpose data container used by Atlus. Code for this emulator lives inside main project's GitHub repository.  </p>"},{"location":"emulators/pak.html#file-types","title":"File Types","text":"<p>This emulator should work with type of PAKs, regardless of what the actual file is named. </p> <p>The most common names/extensions for PAKs are:  </p> <ul> <li>PAK  </li> <li>BIN  </li> <li>PAC  </li> <li>ARC  </li> </ul>"},{"location":"emulators/pak.html#supported-applications","title":"Supported Applications","text":"<p>The only games that have so far been found to use PAKs are Persona games, but theoretically should work with any game that uses them.</p> <p>It has been tested with the following: - Persona 3 Portable (PC) - Persona 4 Golden (PC) - Persona 5 Royal (PC)  </p>"},{"location":"emulators/pak.html#example-usage","title":"Example Usage","text":"<p>A. As currently this mod is for the PC releases of Persona games, you will need to use the extension of Persona Essentials to use with those games. The steps for using on its own are very similar to with that extension. Add a dependency on this mod in your mod configuration. (via <code>Edit Mod</code> menu dependencies section, or in <code>ModConfig.json</code> directly)</p> <pre><code>\"ModDependencies\": [\"reloaded.universal.fileemulationframework.pak\"]\n</code></pre> <p>B. Add a folder called <code>FEmulator/PAK</code> in your mod folder. C. Make folders corresponding to PAK Container names, e.g. <code>init_free.bin</code>.  </p> <p>Files inside PAK Archives are accessed by the name of the original file, i.e. if you want to replace a file called file.tmx in the archive, you would add a file also called file.tmx into your folder.  </p> <p>Inside each folder make files, with names corresponding to the file's name, if the file's name contains a folder path, place the file in a folder of the same name. e each folder make files, with names corresponding to the file's name, if the file's name contains a folder path, place the file in a folder of the same name.  </p>"},{"location":"emulators/pak.html#paks-within-paks","title":"PAKs within PAKs","text":"<p>Various PAK files in the Persona series use PAK files nested within other PAK files. </p> <p>To edit these nested PAKs, simply make a folder within the PAK file folder you already made with the same name as the nested PAK file.</p>"},{"location":"emulators/pak.html#examples","title":"Example(s)","text":"<p>To replace a file in an archive named <code>init_free.bin</code>...</p> <p>Adding <code>FEmulator/PAK/init_free.bin/file.tmx</code> to your mod would add or replace a file named <code>file.tmx</code> in the original PAK Container.</p> <p>Adding <code>FEmulator/PAK/init_free.bin/field/fldEff_rainA.tmx</code> to your mod would add or replace a file named <code>field/fldEff_rainA.tmx</code> in the original PAK Container.</p> <p>Adding <code>FEmulator/PAK/init_free.bin/init/loading.arc/mini_tv.tmx</code> to your mod would add or replace a file named <code>mini_tv.tmx</code> in the PAK file <code>loading.arc</code> within the original PAK Container.</p>"},{"location":"emulators/spd.html","title":"SPD [Atlus]","text":"<p>Info</p> <p>SPD/SPR files are sprite containers used by Atlus. Code for this emulator lives inside main project's GitHub repository.  </p>"},{"location":"emulators/spd.html#file-types","title":"File Types","text":"<p>This emulator should work with any <code>.SPD</code> or <code>.SPR</code> file. </p>"},{"location":"emulators/spd.html#supported-applications","title":"Supported Applications","text":"<ul> <li>Persona 3 Portable (PC)  </li> <li>Persona 4 Golden (PC)  </li> <li>Persona 5 Royal (PC)  </li> </ul>"},{"location":"emulators/spd.html#usage","title":"Usage","text":"<p>As currently this mod is for the PC releases of Persona games, you will need to use the extension of Persona Essentials to use with those games. The steps for using on its own are very similar to with that extension.</p> <p>Add a dependency on this mod in your mod configuration. (via <code>Edit Mod</code> menu dependencies section, or in <code>ModConfig.json</code> directly)</p> <pre><code>\"ModDependencies\": [\"reloaded.universal.fileemulationframework.spd\"]\n</code></pre>"},{"location":"emulators/spd.html#legend","title":"Legend","text":"<ul> <li><code>.SPD</code> or <code>.SPR</code> -- sprite container files.</li> <li><code>.spdspr</code> or <code>.sprt</code> -- sprite entry coordinate files.</li> <li><code>.dds</code> or <code>.tmx</code> -- texture files.</li> </ul> <ul> <li><code>.SPD</code> will be used to refer to both <code>.SPD</code> and <code>.SPR</code> files unless stated otherwise.</li> <li><code>.spdspr</code> will be used to refer to both <code>.spdspr</code> and <code>.sprt</code> files unless stated otherwise.</li> </ul> <ul> <li>Entries from the texture dictionary will be referred to as \"Texture Entries\" or \"Textures\".</li> <li>Entries from the sprite coordinate dictionary will be referred to as \"Sprite Entries\" or \"Sprites\".</li> </ul>"},{"location":"emulators/spd.html#where-to-put-files","title":"Where to put files","text":"<p>Add a folder called <code>FEmulator/SPD</code> in your mod folder. Make folders corresponding to SPD Container paths, e.g. <code>font/chat/chat.spd/</code>. All files used for SPD Emulation should be placed in this folder.</p>"},{"location":"emulators/spd.html#sprites-in-pak-files","title":"Sprites in PAK Files","text":"<p>Recreate the directory to the SPD inside the PAK, and create a dummy file with the name of the sprite file in that directory. A dummy file can be made my making an empty .txt file and giving it the name of the sprite file.</p> <p>Example: <code>FEmulator/PAK/init_free.bin/smap/i_mini_map01.spr</code></p>"},{"location":"emulators/spd.html#tools","title":"Tools","text":"<p>There are 3 tools you're going to want to make use of when preparing files for the SPD Emulator:</p> <ul> <li>Amicitia</li> <li>PersonaEditor</li> <li>PersonaSpriteTools (optional)</li> </ul>"},{"location":"emulators/spd.html#extracting-textures-and-sprites","title":"Extracting textures and sprites","text":"<ul> <li>Amicitia can extract both textures and sprite entries.</li> <li>PersonaEditor can only extract textures.</li> <li>PersonaSpriteTools can extract both textures and sprite entries using <code>ExtractSprite.py</code></li> </ul>"},{"location":"emulators/spd.html#finding-sprite-information","title":"Finding Sprite Information","text":"<ul> <li>Amicitia will display the texture id above the texture window when a texture is selected, same with sprite entry ids.</li> <li>PersonaEditor will display the texture id and sprite id next to each sprite entry in the spd edit window.</li> <li>PersonaSpriteTools' <code>ExtractSprite.py</code> will have each sprite id in the sprite entry's file name, and the sprite entry files will be put in a folder with the id of the texture they belong to.</li> </ul>"},{"location":"emulators/spd.html#editing-sprite-files","title":"Editing Sprite Files","text":"<p><code>.SPD</code> files are made up of 3 parts. The header, the textures, and the sprite coordinates. The header will be built automatically by the emulator, and allows mod creators to patch the last two.</p> <p>The emulator provides 3 ways to edit <code>.SPD</code> files:</p> <ul> <li>Sprite patching</li> <li>Texture replacement</li> <li>Adding new sprites (advanced)</li> </ul> <p>Warning</p> <p>Custom texture dimensions must conform to 2^n or (2^n + 2^n-1) to prevent crashes. (ex: 384x192, 1024x512, 768x1536)</p>"},{"location":"emulators/spd.html#patching-sprites","title":"Patching Sprites","text":"<p>Sprite patching in this context refers to the technique of appending a provided texture to the <code>.SPD</code>s texture dictionary, and patching a sprite entry to point to the new texture.</p> <p>After editing the texture containing the sprite you want to change, change the texture's filename to reflect the appropriate sprite id(s), which can be found using PersonaEditor. </p> <p>The filename should be <code>spr_x.dds</code> where <code>x</code> is the sprite ids, using Id Notation.</p> <p>Textures should be the same size as the originals, and the sprites should be in the same place, unless you're supplying an edited <code>.spdspr</code> file.</p> <p>If you are supplying an edited <code>.spdspr</code> file, the filename should be <code>spr_x.spdspr</code> (or <code>.sprt</code>) with <code>x</code> being the sprites id.</p> <p>Warning</p> <p>Moving around sprite positions may occasionally break sprite positioning. This has only been observed with P5R so far, and affects sprites that appear next to button prompts as well as a lot of the pause menu animation sprites. These sprites must be put into an image with the same size as the original with the sprites in the correct positions in order to be displayed correctly.</p>"},{"location":"emulators/spd.html#examples","title":"Examples","text":"<ul> <li>To edit sprite id 15, name the texture <code>spr_15.dds</code>.</li> <li>To edit sprites 15 and 20, name the texture <code>spr_15_20.dds</code></li> <li>To edit sprites 15, 20, 25-30, and 45-55, name the texture <code>spr_15_20_25-30_45-55.dds</code></li> </ul>"},{"location":"emulators/spd.html#replacing-textures","title":"Replacing Textures","text":"<p>Under the hood, texture replacement is really just sprite patching, but affects every sprite that pointed to the original texture.</p> <p>To replace a texture, simply name your edited texture <code>tex_x.dds</code> where <code>x</code> is the id of the texture.</p> <p>You may also want to exclude some sprites from being affected by this method. You can do this by adding a tilda <code>~</code> at the end of the texture name, followed by the sprite ids in Id Notation.</p>"},{"location":"emulators/spd.html#example","title":"Example","text":"<ul> <li>To replace all sprites in texture id 4, name the texture <code>tex_4.dds</code></li> <li>To replace all sprites in texture id 4 except for sprite id 15-20, and 24, name the texture <code>tex_4~15-20_24.dds</code> </li> </ul>"},{"location":"emulators/spd.html#adding-new-sprites","title":"Adding New Sprites","text":"<p>Adding a new sprite works similarly to patching sprites, but requires that an accompanying sprite entry file be present.</p>"},{"location":"emulators/spd.html#example_1","title":"Example","text":"<p>To add a previously non-existent sprite id 420, create a sprite entry file named <code>spr_420.spdspr</code>, and name the texture <code>spr_420.dds</code>. You can add multiple new sprites by putting multiple sprite entry files, and naming the texture using Id Notation.</p>"},{"location":"emulators/spd.html#id-notation","title":"Id Notation","text":"<p>Both sprite patching and texture replacement allow for multiple sprites to be patched/excluded. sprite ranges are denoted by dashes <code>-</code>, and sprite ids and ranges are separated by underscores <code>_</code>.</p>"},{"location":"emulators/spd.html#examples_1","title":"Examples","text":"<ul> <li>1 = 1</li> <li>1_5 = 1 and 5</li> <li>1-5 = 1 through 5</li> <li>1-5_10 1 through 5, and 10</li> </ul>"},{"location":"guides/contributing-locally.html","title":"Contributing to the Index: Locally","text":""},{"location":"guides/contributing-locally.html#tutorial","title":"Tutorial","text":"<p>You should learn the basics of <code>git</code>, an easy way is to give GitHub Desktop (Tutorial) a go. It's only 15 minutes \ud83d\ude00.</p> <ol> <li>Create a GitHub account.</li> <li> <p>Fork this repository:</p> <p></p> <p>This will create a copy of the repository on your own user account, which you will be able to edit.</p> </li> <li> <p>Clone this repository.</p> <p>For example, using GitHub Desktop: </p> </li> <li> <p>Make changes inside the <code>docs</code> folder.</p> <p></p> <p>Consider using a Markdown Cheat Sheet if you are new to markdown.</p> <p>I recommend using a markdown editor such as <code>Typora</code>. Personally I use Visual Studio Code, which has built-in markdown support and preview available (<code>Ctrl+Shift+P</code> -&gt; <code>Markdown: Open Preview</code>). </p> </li> <li> <p>Commit the changes and push to GitHub.</p> </li> <li> <p>Open a <code>Pull Request</code>.</p> <p></p> <p>Opening a <code>Pull Request</code> will allow us to review your changes before adding them with the main official page. If everything's good, we'll hit the merge button and add your changes to the official repository.</p> </li> </ol>"},{"location":"guides/contributing-locally.html#website-live-preview","title":"Website Live Preview","text":"<p>If you are working on the Index locally, you can generate a live preview the full website. Here's a quick guide of how you could do it from your <code>command prompt</code> (cmd).</p> <ol> <li> <p>Install Python 3</p> <p>If you have <code>winget</code> installed, or Windows 11, you can do this from the command prompt. <pre><code>winget install Python.Python.3\n</code></pre></p> <p>Otherwise download Python 3 from the official website.</p> </li> <li> <p>Install Material for MkDocs (Python package)     <pre><code># Restart your command prompt before running this command.\npip install mkdocs-material\n</code></pre></p> </li> <li> <p>Open a command prompt in the Index folder and run the site locally.     <pre><code># Move to Index folder.\ncd &lt;Replace this with full path to your Index folder&gt;\nmkdocs serve\n</code></pre></p> <p></p> <p>Copy the address to your web browser and enjoy the live preview; any changes you save will be shown instantly.</p> </li> </ol>"},{"location":"guides/contributing-online.html","title":"Contributing to the Index: Online","text":"<p>(If you want to work purely in your web browser, recommended for small changes only)</p> <ol> <li>Create a GitHub Account.</li> <li> <p>Fork this repository:</p> <p></p> <p>This will create a copy of the repository on your own user account, which you will be able to edit.</p> </li> <li> <p>Open the <code>docs</code> folder and edit the relevant (.md) pages.</p> <p></p> <p>Consider using a Markdown Cheat Sheet for your editing needs.</p> </li> <li> <p>Open a <code>Pull Request</code>.</p> <p></p> <p>Opening a <code>Pull Request</code> will allow us to review your changes before adding them with the main official page. If everything's good, we'll hit the merge button and add your changes to the official repository.</p> </li> </ol>"}]}